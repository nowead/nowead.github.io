+++
date = '2025-09-07T10:00:00+09:00'
draft = false
title = '[Vulkan] Ep03. Vulkan의 큰 그림'
series = ["Vulkan 학습"]
tags = ["Vulkan", "Overview", "Architecture"]
categories = ["그래픽스 프로그래밍"]
+++

## 시작하며

코드를 작성하기 전, [Vulkan Tutorial - Overview](https://docs.vulkan.org/tutorial/latest/01_Overview.html)를 읽어보았다. 너무 튜토리얼의 순서대로만 따라가다 보면 "도대체 이걸 왜 지금 왜 하고 있는거지?"라는 의문에 빠질 것 같았다.

단순히 튜토리얼을 읽어 보는 것을 넘어, **엔진 개발자 관점에서 Vulkan의 핵심 구성 요소**를 5가지 계층으로 나누어 정리해보았다. 이 구조를 머릿속에 넣고 시작해야 길을 잃지 않을 것 같다.

## 1. 초기화 및 장치 계층 (System Setup)

가장 먼저 Vulkan을 사용하기 위한 환경을 구축하는 단계다. 하드웨어와 소프트웨어를 연결하는 기초 공사라고 볼 수 있다.

- **Instance (인스턴스)**
  - 내 프로그램과 Vulkan 라이브러리를 연결하는 접점이다.
  - 개발 단계에서는 여기서 **Validation Layer(검증 레이어)**를 반드시 활성화해서 내가 짠 코드의 오류를 잡아야 한다.

- **Physical Device (물리 장치)**
  - 실제 그래픽 카드(GPU)를 말한다.
  - VRAM 크기나 지원 기능(Feature)을 조회해서 내 프로그램에 적합한 GPU를 선택하는 과정이다.

- **Logical Device (논리 장치)**
  - 선택한 물리 장치를 소프트웨어적으로 추상화한 객체다.
  - 앞으로 사용할 대부분의 Vulkan 함수는 이 논리 장치를 통해 호출된다.

## 2. 명령 및 실행 계층 (Command & Execution)

Vulkan은 함수를 호출한다고 바로 실행되지 않는다. **"녹화(Record) 후 제출(Submit)"**하는 방식이다.

- **Queue (큐)**
  - GPU에게 작업을 요청하는 통로다. (그래픽, 연산, 전송 큐 등으로 나뉜다.)
  - 멀티스레드 환경에서 여러 커맨드 버퍼를 녹화한 뒤, 큐에 한꺼번에 제출할 수 있어 효율적이다.

- **Command Pool (커맨드 풀)**
  - 커맨드 버퍼를 만들기 위한 메모리 관리자다. 특정 큐 패밀리(Queue Family)와 연결된다.

- **Command Buffer (커맨드 버퍼)**
  - 실제 그리기 명령(`vkCmdDraw`)이나 메모리 복사 명령 등을 **녹화**하는 테이프다.
  - 매 프레임 새로 녹화할 수도 있고, 미리 녹화해둔 것을 재사용할 수도 있다.

## 3. 렌더링 및 파이프라인 (Rendering & Pipeline)

화면에 "무엇을, 어떻게" 그릴지 정의하는 단계다. Vulkan에서 가장 설정이 많은 부분이다.

- **Swapchain (스왑체인)**
  - 화면에 출력될 이미지 버퍼들의 리스트다.
  - 더블 버퍼링, 트리플 버퍼링 같은 프레젠테이션 모드를 여기서 관리한다.

- **Render Pass (렌더 패스)**
  - 렌더링 작업의 전체적인 시나리오다.
  - "어떤 이미지에 그릴 것인가?", "그리기 전에 지울 것인가(LoadOp)?", "다 그리고 저장할 것인가(StoreOp)?" 같은 규칙을 정의한다.

- **Pipeline (파이프라인)**
  - GPU의 상태(State)를 미리 **구워놓은(Bake)** 불변 객체다.
  - 셰이더(Vertex, Fragment), 블렌딩, 깊이 테스트, 래스터라이저 설정 등이 모두 포함된다.
  - **중요:** Vulkan에서 파이프라인 변경은 비용이 크다. 따라서 필요한 파이프라인들을 미리 여러 개 생성해두고 교체하며 쓰는 것이 정석이다.

## 4. 자원 및 데이터 바인딩 (Resources & Descriptors)

셰이더에 데이터를 전달하는 방식이다. **Vulkan 입문자가 가장 어려워하는 부분**이라고 한다.

- **Buffer & Image**
  - 정점(Vertex), 인덱스, 텍스처 등 실제 데이터가 담기는 메모리다.
  - CPU에서 바로 GPU로 보내지 않고, **Staging Buffer**를 통해 최적화된 전송을 하는 기법을 주로 쓴다.

- **Descriptor (디스크립터)**
  - 셰이더가 리소스(유니폼 버퍼, 텍스처 등)에 접근할 수 있게 해주는 **'연결 고리(포인터)'** 다.
    - **Descriptor Set Layout**: 셰이더가 어떤 데이터를 받을지 정의한 '설계도'.
    - **Descriptor Set**: 실제 리소스를 바인딩한 '구현체'.

## 5. 동기화 (Synchronization)

Vulkan은 드라이버가 실행 순서를 보장해주지 않는다. 개발자가 직접 교통 정리를 해야 한다.

- **Semaphore (세마포어)**
  - **GPU 내부**의 작업 간 동기화.
  - 예: "이미지 준비(Acquire)가 끝나야 렌더링을 시작해라."

- **Fence (펜스)**
  - **CPU와 GPU 간**의 동기화.
  - 예: "GPU가 다 그릴 때까지 CPU는 다음 프레임 준비를 하지 말고 기다려라."

## 요약: Vulkan 애플리케이션의 흐름

위 개념들을 종합하면, Vulkan 프로그램은 다음과 같은 흐름으로 돌아간다.

1.  **초기화**: Instance -> Physical Device -> Logical Device 생성.
2.  **준비**: Swapchain 생성, Render Pass 정의, Pipeline 생성(셰이더 컴파일).
3.  **메인 루프 (매 프레임 반복)**:
    - **이미지 확보**: 스왑체인에서 그릴 종이를 가져온다.
    - **녹화**: Command Buffer에 그리기 명령을 기록한다. (Begin -> RenderPass -> Bind Pipeline -> Draw -> End)
    - **제출**: Queue에 커맨드 버퍼를 제출한다. (이때 Semaphore로 순서 제어)
    - **출력**: 다 그려진 이미지를 화면(Present)에 띄운다.

## 마치며

이렇게 정리하고 보니 Vulkan이 왜 "Explicit(명시적)" API라고 불리는지 알 것 같다. 드라이버가 알아서 해주던 것들을 위 5가지 계층으로 나누어 개발자에게 직접 제어하라고 던져준 것이다.

복잡하고 아직 용어가 익숙하지 않아서 무슨 말인지 모르겠다. 다음 ep는 복잡한 용어들의 개념을 확인하고 비유를 통해 어떻게든 외울 수라도 있게 반복적으로 학습할 계획이다.